options{  LOOKAHEAD= 1;  static = true;}PARSER_BEGIN(DSL)import java.io.*;public class DSL{  public static void main(String args [])  {    System.out.println("Reads from directory input/ and Writes to directory output/");    DSL dsl = null;    File [] files;    File file = new File("input/");    files = file.listFiles();    for (int i = 0; i < files.length; i++)    {      System.out.println("-- " + files [i].getName() + " --");      try      {        File toParse = new File(Generator.extractDSLCode(files [i]));        InputStream inputStream = new FileInputStream(toParse);        if (dsl == null) dsl = new DSL(inputStream);        else ReInit(inputStream);        try        {          SimpleNode n = DSL.Start();          n.deleteUninterestingNodes();          n.dump("");          Warning.dump();          Generator gen = new Generator(files [i], n);          System.out.println("Successfully Parsed and Generated!\n");          // Clear all the static stuff for the next file parsing          VariableStore.clear();          MyVariable.clear();          Warning.clear();        }        catch (SemanticException e)        {          System.err.println("::: Semantic Error :::");          System.err.println(e.getMessage());        }        catch (Exception e)        {          System.err.println("::: Syntax Error :::");          System.err.println(e.getMessage());        }      }      catch (IOException e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());      }    }  }}PARSER_END(DSL)SKIP :{  " "| "\r"| "\t"| "\n"  //| "[^/\*@mat]*/\*@mat[^\*/]\*/"}/*OPERATORS */TOKEN :{  < IN : "in" >| < OUT : "out" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < FLOAT : "float" >| < INT : "int" >| < DOUBLE : "double" >| < LPAREN : "(" >| < RPAREN : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < ASSIGN : "=" >| < COLON : ":" >}//TOKEN :{  < INTEGER : ([ "0"-"9" ])+ >| < DECIMAL_NUMBER : < INTEGER > "." < INTEGER >>| < VAR :    (      [ "A"-"Z", "a"-"z" ] ([ "0"-"9", "A"-"Z", "a"-"z" ])*    ) >| < ARROBAMAT : "@mat" >| < LETTERS : ([ "A"-"Z", "a"-"z" ])+ >}SimpleNode Start() throws SemanticException :{}{  parseDSL()  {    return jjtThis;  }}void parseDSL() throws SemanticException #void :{}{  "/*@mat" dslStatements() "*/"}void dslStatements() throws SemanticException #void :{}{  (    dslLine()  )+}void dslLine() throws SemanticException #void :{}{  dslDeclaration() < SEMICOLON >| dslAtribution() < SEMICOLON >}Token dslDataType() #void :{  Token t;}{  (    t = < INT >  | t = < FLOAT >  | t = < DOUBLE >  )  {    return t;  }}void dslDeclaration() throws SemanticException #void :{  Token t1, t2, t3, t4;  boolean gotRanged = false;}{  (t1 = < IN >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET >  (    (t4 = < INTEGER >) /* Has range declared */    {      //MyVariable.rangeOnDeclaration = true;      if (!MyVariable.checkRange(Integer.parseInt(t4.image))) throw new SemanticException("Variable " + t3.image + " has a wrong range for a matrix (sqrt(" + t4.image + ") is valid for no. of rows).");      gotRanged = true;      VariableStore.add(new MyVariable(t3.image, t2, t1, Integer.parseInt(t4.image)));    }  )?  < RBRACKET >  {    if (!gotRanged)    {      VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));    }  }| (t1 = < OUT >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET > < RBRACKET >  {    VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));  }}void dslAtribution() throws SemanticException : // TAG WITH ={  Token t, t1;  Integer [ ] indxRange = null;}{  (    t1 = dslVarAtr()  )  (    (t = < ASSIGN >) dslExpr() // SEM RANGE  |    (      indxRange = dslVarWithRange(t1)    )    (t = < ASSIGN >) dslExpr2() // COM RANGE  )  {    jjtThis.symbol = t.image;    jjtThis.indicesRange = indxRange;    int rangeDeclaration = VariableStore.getRange(jjtThis.symbol);    if (indxRange != null)      if (rangeDeclaration != -1 && rangeDeclaration <= jjtThis.indicesRange [ 1 ]) throw new SemanticException("Range defined in operation bigger than range declared in declaration on variable " + jjtThis.symbol);  }}Token dslVarAtr() throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {    jjtThis.symbol = t.image;    //VariableStore.dump();    switch (VariableStore.checkVariable(t.image, false))    {      case 0 : throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");      break;      case 1 : throw new SemanticException("Variable " + t.image + " is in the wrong call order. Should be used as input and not as output.");      break;      default : break;    }    return t;  }  #Term}Token dslVar()throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {    switch (VariableStore.checkVariable(t.image, true))    {      case 0 : throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");      break;      case 1 : throw new SemanticException("Variable " + t.image + " is in the wrong call order. Should be used as output and not as input.");      break;      default : break;    }    return t;  }}Integer [ ] dslVarWithRange(Token var) throws SemanticException #void :{  Token t1, t2;}{  < LPAREN > (t1 = < INTEGER >) < COLON > (t2 = < INTEGER >) < RPAREN >  {    //if (MyVariable.rangeOnDeclaration) throw new ParseException("Range Specified on Declaration. Specify it only in one place!");    int r1, r2;    if ((r1 = Integer.parseInt(t1.image)) >= (r2 = Integer.parseInt(t2.image))) throw new SemanticException("Wrong Range Values.!" + r2 + " should be less than " + r1);    if (!MyVariable.checkRange((r2 + 1 - r1))) throw new SemanticException("Variable has a wrong range (" + r1 + ":" + r2 + ") for a matrix (sqrt() is valid for no. of rows).");    Integer [ ] retorno = new Integer [ 2 ];    retorno [ 0 ] = new Integer(r1);    retorno [ 1 ] = new Integer(r2);    return retorno;    //if (Math.sqrt(r2-r1) == double) throw new SemanticException();    //if (MyVariable.range < r + 1) MyVariable.range = r + 1;    //VariableStore.setRange(var.image, r+1);  }}void dslExpr() throws SemanticException :{  String s;}{  dslTerm() s = dslTermTail()  {    if (s != null) jjtThis.symbol = s;  }}void dslTerm() throws SemanticException :{  String s;}{  dslFactor() s = dslFactorTail()  {    if (s != null) jjtThis.symbol = s;  }}String dslTermTail() throws SemanticException :{  Token t;  String s;}{  t = dslAddOp() dslTerm() s = dslTermTail()  {    //jjtThis.symbol = t.image;    if (s != null) jjtThis.symbol = s;    return t.image;  }|  {}  {    return null;  }}void dslFactor() throws SemanticException :{  Token t;}{  (    < LPAREN > dslExpr() < RPAREN >  | t = dslVar()    {      jjtThis.symbol = t.image;    }  )}String dslFactorTail() throws SemanticException :{  Token t;  String s;}{  (    t = dslMultOp() dslFactor() s = dslFactorTail()    {      //jjtThis.symbol = t.image;      if (s != null) jjtThis.symbol = s;      return t.image;    }  |    {}    {      return null;    }  )}// Handling the variables having inline range definedvoid dslExpr2() throws SemanticException :{  String s;}{  dslTerm2() s = dslTermTail2()  {    if (s != null) jjtThis.symbol = s;  }}void dslTerm2() throws SemanticException :{  String s;}{  dslFactor2() s = dslFactorTail2()  {    if (s != null) jjtThis.symbol = s;  }}String dslTermTail2() throws SemanticException :{  Token t;  String s;}{  t = dslAddOp() dslTerm2() s = dslTermTail2()  {    if (s != null) jjtThis.symbol = s;    return t.image;  }|  {}  {    return null;  }}void dslFactor2() throws SemanticException :{  Token t;  Integer [ ] indxRange;}{  (    < LPAREN > dslExpr2() < RPAREN >  |    (      t = dslVar()    )    indxRange = dslVarWithRange(t)    {      jjtThis.symbol = t.image;      jjtThis.indicesRange = indxRange;      int rangeDeclaration = VariableStore.getRange(jjtThis.symbol);      if (rangeDeclaration != -1 && rangeDeclaration <= jjtThis.indicesRange [ 1 ]) throw new SemanticException("Range defined in operation bigger than range declared in declaration on variable " + jjtThis.symbol);    }  )}String dslFactorTail2() throws SemanticException :{  Token t;  String s;}{  (    t = dslMultOp() dslFactor2() s = dslFactorTail2()    {      //jjtThis.symbol = t.image;      if (s != null) jjtThis.symbol = s;      return t.image;    }  |    {}    {      return null;    }  )}Token dslAddOp() #void :{  Token t;}{  (    (t = < PLUS >)  | (t = < MINUS >)  )  {    return t;  }}Token dslMultOp() #void :{  Token t;}{  (    (t = < STAR >)  | (t = < SLASH >)  )  {    return t;  }}