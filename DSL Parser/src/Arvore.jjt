options{  LOOKAHEAD= 1;  static = true;}PARSER_BEGIN(DSL)import java.io.*;public class DSL{  public static void main(String args [])  {    System.out.println("Reads from directory input/ and Writes to directory output/");    DSL dsl=null;    File [] files;    File file = new File("input/");    files = file.listFiles();    for (int i = 0; i < files.length; i++)    {      System.out.println("-- " + files [i].getName() + " --");      try      {        InputStream inputStream = new FileInputStream(files [i]);        if(dsl == null) dsl = new DSL(inputStream);        else ReInit(inputStream);        try        {          SimpleNode n = DSL.Start();          n.deleteUninterestingNodes();          n.dump("");          Warning.dump();          Generator gen = new Generator(files[i], n);          System.out.println("Successfully Parsed and Generated!\n");		  // Clear all the static stuff for the next file parsing          VariableStore.clear();          MyVariable.clear();          Warning.clear();        }        catch (SemanticException e)        {          System.err.println("::: Semantic Error :::");          System.err.println(e.getMessage());        }        catch (Exception e)        {          System.err.println("::: Syntax Error :::");          System.err.println(e.getMessage());        }      }      catch (IOException e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());      }    }  }}PARSER_END(DSL)SKIP :{  " "| "\r"| "\t"| "\n"//| "[^/\*@mat]*/\*@mat[^\*/]\*/"}/*OPERATORS */TOKEN :{  < IN : "in" >| < OUT : "out" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < FLOAT : "float" >| < INT : "int" >| < DOUBLE : "double" >| < LPAREN : "(" >| < RPAREN : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < ASSIGN : "=" >| < COLON : ":" >}//TOKEN :{  < INTEGER : ([ "0"-"9" ])+ >| < DECIMAL_NUMBER : < INTEGER > "." < INTEGER >>| < VAR :    (      [ "A"-"Z", "a"-"z" ] ([ "0"-"9", "A"-"Z", "a"-"z" ])*    ) >| < ARROBAMAT : "@mat" >| < LETTERS : ([ "A"-"Z", "a"-"z" ])+ >//| < CYCLEIN : ^["@mat"]>//| < CYCLEOUT : >}SimpleNode Start() throws SemanticException :{}{  parseDSL()  {    return jjtThis;  }}void parseDSL() throws SemanticException #void :{}{  "/*@mat" dslStatements() "*/" <EOF>}void dslStatements() throws SemanticException #void :{}{  (    dslLine()  )+}void dslLine() throws SemanticException #void :{}{  dslDeclaration() < SEMICOLON >| dslAtribution() < SEMICOLON >}Token dslDataType() #void :{  Token t;}{  (    t = < INT >  | t = < FLOAT >  | t = < DOUBLE >  )  {    return t;  }}void dslDeclaration() throws SemanticException #void :{  Token t1, t2, t3, t4;  boolean gotRanged = false;}{  (t1 = < IN >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET >  (    (t4 = < INTEGER >) /* Has range declared */    {      MyVariable.rangeOnDeclaration = true; 	  if(!MyVariable.checkRange(Integer.parseInt(t4.image))) 	  	throw new SemanticException("Variable " + t3.image + 	  								" has a wrong range for a matrix (sqrt(" + t4.image + ") is valid for no. of rows).");      gotRanged = true;      VariableStore.add(new MyVariable(t3.image, t2, t1, Integer.parseInt(t4.image)));    }  )?  < RBRACKET >  {    if (!gotRanged)    {      VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));    }  }| (t1 = < OUT >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET > < RBRACKET >  {    VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));  }}void dslAtribution() throws SemanticException : // TAG WITH ={  Token t, t1;}{  (t1=dslVarAtr())  (    (t = < ASSIGN >) dslExpr() // SEM RANGE  | dslVarWithRange(t1) (t = < ASSIGN >) dslExpr2() // COM RANGE  )  {    jjtThis.symbol = t.image;  }}Token dslVarAtr() throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {    jjtThis.symbol = t.image;    //VariableStore.dump();    switch(VariableStore.checkVariable(t.image, false))    {    case 0:      throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");      break;    case 1:      throw new SemanticException("Variable " + t.image + " is in the wrong call order. Should be used as input and not as output.");      break;    default:      break;	}    return t;  } #Term}Token dslVar() throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {	switch(VariableStore.checkVariable(t.image, true))    {    case 0:      throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");      break;    case 1:      throw new SemanticException("Variable " + t.image + " is in the wrong call order. Should be used as output and not as input.");      break;    default:      break;	}    return t;  }}void dslVarWithRange(Token var) #void :{  Token t1, t2;}{  < LPAREN > (t1 = < INTEGER >) < COLON > (t2 = < INTEGER >) < RPAREN >  {    if (MyVariable.rangeOnDeclaration) throw new ParseException("Range Specified on Declaration. Specify it only in one place!");    int r;    if (Integer.parseInt(t1.image) > (r = Integer.parseInt(t2.image))) throw new ParseException("Wrong Range Values!");    if (MyVariable.range < r + 1) MyVariable.range = r + 1;    VariableStore.setRange(var.image, r+1);  }}void dslExpr() throws SemanticException :{  String s;}{  dslTerm() s = dslTermTail()  {    if (s != null) jjtThis.symbol = s;  }}void dslTerm() throws SemanticException :{String s;}{  dslFactor() s=dslFactorTail()  {    if (s != null) jjtThis.symbol = s;  }}String dslTermTail() throws SemanticException :{  Token t; String s;}{  t = dslAddOp() dslTerm() s=dslTermTail()  {    //jjtThis.symbol = t.image;    if (s != null) jjtThis.symbol = s;    return t.image;  }|  {}  {    return null;  }}void dslFactor() throws SemanticException :{  Token t;}{  (    < LPAREN > dslExpr() < RPAREN >  | t = dslVar()    {      jjtThis.symbol = t.image;    }  )}String dslFactorTail() throws SemanticException :{  Token t; String s;}{  (    t = dslMultOp() dslFactor() s=dslFactorTail()    {      //jjtThis.symbol = t.image;      if (s != null) jjtThis.symbol = s;      return t.image;    }  |    {}    {      return null;    }  )}// Handling the variables having inline range definedvoid dslExpr2() throws SemanticException #void :{}{  dslTerm2() dslTermTail2()}void dslTerm2() throws SemanticException #void :{}{  dslFactor2() dslFactorTail2()}void dslTermTail2() throws SemanticException #void :{}{  dslAddOp() dslTerm2() dslTermTail2()|  {}}void dslFactor2() throws SemanticException :{Token t;}{  < LPAREN > dslExpr2() < RPAREN >| (t=dslVar()) dslVarWithRange(t) // TERM}void dslFactorTail2() throws SemanticException #void :{}{  dslMultOp() dslFactor2() dslFactorTail2()|  {}}Token dslAddOp()  :{  Token t;}{  (    (t = < PLUS >)  | (t = < MINUS >)  )  {    return t;  }}Token dslMultOp()  :{  Token t;}{  (    (t = < STAR >)  | (t = < SLASH >)  )  {    return t;  }}