options{  LOOKAHEAD= 1;  static = true;}PARSER_BEGIN(DSL)import java.io.*;public class DSL{  public static void main(String args [])  {    System.out.println("Reading from directory testUnits/");    File [] files;    File file = new File("testUnits/");    files = file.listFiles();    for (int i = 0; i < files.length; i++)    {      System.out.println("-- " + files [i].getName() + " --");      try      {        InputStream inputStream = new FileInputStream(files [i]);        new DSL(inputStream);        try        {          SimpleNode n = DSL.Start();          n.deleteUninterestingNodes();          n.dump("");          Warning.dump();          System.out.println("Successfully Parsed and Generated!\n");		  // Clear all the static stuff for the next file parsing          VariableStore.clear();          MyVariable.clear();          Warning.clear();        }        catch (SemanticException e)        {          VariableStore.dump();          System.err.println("::: Semantic Error :::");          System.err.println(e.getMessage());        }        catch (Exception e)        {          System.err.println("::: Syntax Error :::");          System.err.println(e.getMessage());        }      }      catch (FileNotFoundException e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());      }    }  }}PARSER_END(DSL)SKIP :{  " "| "\r"| "\t"| "\n"}/*OPERATORS */TOKEN :{  < IN : "in" >| < OUT : "out" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < FLOAT : "float" >| < INT : "int" >| < DOUBLE : "double" >| < LPAREN : "(" >| < RPAREN : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < ASSIGN : "=" >| < COLON : ":" >}//TOKEN :{  < INTEGER : ([ "0"-"9" ])+ >| < DECIMAL_NUMBER : < INTEGER > "." < INTEGER >>| < VAR :    (      [ "A"-"Z", "a"-"z" ] ([ "0"-"9", "A"-"Z", "a"-"z" ])*    ) >| < ARROBAMAT : "@mat" >| < LETTERS : ([ "A"-"Z", "a"-"z" ])+ >}// /*@mat in int A[]; in float B[100]; out float C[]; C=A+B; */SimpleNode Start() throws SemanticException :{}{  parseDSL()  {    return jjtThis;  }}void parseDSL() throws SemanticException #void :{}{  "/*@mat" dslStatements() "*/"}void dslStatements() throws SemanticException #void :{}{  (    dslLine()  )+}void dslLine() throws SemanticException #void :{}{  dslDeclaration() < SEMICOLON >| dslAtribution() < SEMICOLON >}Token dslDataType() #void :{  Token t;}{  (    t = < INT >  | t = < FLOAT >  | t = < DOUBLE >  )  {    return t;  }}void dslDeclaration() #void :{  Token t1, t2, t3, t4;  boolean gotRanged = false;}{  (t1 = < IN >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET >  (    (t4 = < INTEGER >) /* Has range declared */    {      MyVariable.rangeOnDeclaration = true;      gotRanged = true;      VariableStore.add(new MyVariable(t3.image, t2, t1, Integer.parseInt(t4.image)));      System.out.println("Range - Added Var " + t3.image + " "+ t2.image + " " + Integer.parseInt(t4.image));    }  )?  < RBRACKET >  {    if (!gotRanged)    {      VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));      System.out.println("No Range - Added Var " + t3.image + " "+ t2.image);    }  }| (t1 = < OUT >)  (    t2 = dslDataType()  )  (t3 = < VAR >) < LBRACKET > < RBRACKET >  {    VariableStore.add(new MyVariable(t3.image, t2, t1, - 1));    System.out.println("No Range - Added Var " + t3.image + " "+ t2.image);  }}void dslAtribution() throws SemanticException : // TAG WITH ={  Token t;}{  dslVarAtr()  (    (t = < ASSIGN >) dslExpr() // SEM RANGE  | dslVarWithRange() (t = < ASSIGN >) dslExpr2() // COM RANGE  )  {    jjtThis.symbol = t.image;  }}void dslVarAtr() throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {    jjtThis.symbol = t.image;    if(!VariableStore.hasVariable(t.image, false))    	throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");  } #Term}Token dslVar() throws SemanticException #void :{  Token t;}{  (t = < VAR >)  {	if(!VariableStore.hasVariable(t.image, true))    	throw new SemanticException("Variable " + t.image + " was not instantiated or is not a valid keyword.");    return t;  }}void dslVarWithRange() #void :{  Token t1, t2;}{  < LPAREN > (t1 = < INTEGER >) < COLON > (t2 = < INTEGER >) < RPAREN >  {    if (MyVariable.rangeOnDeclaration) throw new ParseException("Range Specified on Declaration. Specify it only in one place!");    int r;    if (Integer.parseInt(t1.image) > (r = Integer.parseInt(t2.image))) throw new ParseException("Wrong Range Values!");    if (MyVariable.range < r + 1) MyVariable.range = r + 1;  }}void dslExpr() throws SemanticException :{  String s;}{  dslTerm() s = dslTermTail()  {    if (s != null) jjtThis.symbol = s;  }}void dslTerm() throws SemanticException :{String s;}{  dslFactor() s=dslFactorTail()  {    if (s != null) jjtThis.symbol = s;  }}String dslTermTail() throws SemanticException :{  Token t; String s;}{  t = dslAddOp() dslTerm() s=dslTermTail()  {    //jjtThis.symbol = t.image;    if (s != null) jjtThis.symbol = s;    return t.image;  }|  {}  {    return null;  }}void dslFactor() throws SemanticException :{  Token t;}{  (    < LPAREN > dslExpr() < RPAREN >  | t = dslVar()    {      jjtThis.symbol = t.image;    }  )}String dslFactorTail() throws SemanticException :{  Token t; String s;}{  (    t = dslMultOp() dslFactor() s=dslFactorTail()    {      //jjtThis.symbol = t.image;      if (s != null) jjtThis.symbol = s;      return t.image;    }  |    {}    {      return null;    }  )}// Handling the variables having inline range definedvoid dslExpr2() throws SemanticException #void :{}{  dslTerm2() dslTermTail2()}void dslTerm2() throws SemanticException #void :{}{  dslFactor2() dslFactorTail2()}void dslTermTail2() throws SemanticException #void :{}{  dslAddOp() dslTerm2() dslTermTail2()|  {}}void dslFactor2() throws SemanticException :{}{  < LPAREN > dslExpr2() < RPAREN >| dslVar() dslVarWithRange() // TERM}void dslFactorTail2() throws SemanticException #void :{}{  dslMultOp() dslFactor2() dslFactorTail2()|  {}}Token dslAddOp()  :{  Token t;}{  (    (t = < PLUS >)  | (t = < MINUS >)  )  {    return t;  }}Token dslMultOp()  :{  Token t;}{  (    (t = < STAR >)  | (t = < SLASH >)  )  {    return t;  }}