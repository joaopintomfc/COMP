import java.util.Arrays;
import java.util.Scanner;

import javax.crypto.Cipher;

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class SimpleNode implements Node {

	protected Node parent;
	protected Node[] children;
	protected int id;
	protected Object value;
	protected DSL parser;
	public String symbol; /* Can be an operator or a name of a variable */
	public Integer[] indicesRange;

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(DSL p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}

	public void deleteChild(int i) {

		children[i] = null;
		Node[] childrenTemp = new Node[children.length - 1];
		for (int a = i + 1; a < children.length; a++) {
			children[a - 1] = children[a];
		}

		for (int a = 0; a < childrenTemp.length; a++) {
			childrenTemp[a] = children[a];
		}

		children = new Node[childrenTemp.length];

		for (int a = 0; a < children.length; a++) {
			children[a] = childrenTemp[a];
		}
	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	public void jjtSetValue(Object value) {
		this.value = value;
	}

	public Object jjtGetValue() {
		return value;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to
	 * customize the way the node appears when the tree is dumped. If your
	 * output uses more than one line you should override toString(String),
	 * otherwise overriding toString() is probably all you need to do.
	 */

	public String toString() {
		return DSLTreeConstants.jjtNodeName[id];
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */
	public void appendChild(Node n) {
		int i = jjtGetNumChildren();
		this.jjtAddChild(n, i);
	}

	public void deleteChild(Node n) {
		for (int i = 0; i < jjtGetNumChildren(); i++) {
			if (n == children[i])
				deleteChild(i);
		}
	}

	/*
	 * public boolean deleteFactorAfterTerm(){
	 * 
	 * if (this.toString().equals("dslTerm") && this.children.length != 0 &&
	 * this.children[0].toString().equals("dslFactor") &&
	 * this.children[0].getSymbol() == null) { Node parent =
	 * this.jjtGetParent(); System.out.println("ENTROU");
	 * 
	 * 
	 * 
	 * 
	 * for (int i = 0; i < parent.jjtGetNumChildren(); i++) { if (this ==
	 * parent.jjtGetChild(i)) { parent.deleteChild(i); break; } }
	 * 
	 * for (int i = 0; i < jjtGetNumChildren(); i++) {
	 * parent.appendChild(this.children[i]); children[i].jjtSetParent(parent); }
	 * 
	 * this.jjtSetParent(null);
	 * 
	 * return true; } else { for (int i = 0; i < jjtGetNumChildren(); i++) {
	 * 
	 * Node actualChild = children[i]; // String strChildren =
	 * children[i].toString(); boolean apagou =
	 * children[i].deleteFactorAfterTerm(); if (apagou) {
	 * deleteChild(actualChild); i--; } } return false; } }
	 */

	public boolean deleteUninterestingNodes() {
		// Scanner n = new Scanner(System.in);
		// this.dump("");
		// n.next();

		// String strParent = toString();
		// Node to delete
		if (this.symbol == null && jjtGetParent() != null) {
			Node parent = this.jjtGetParent();
			int indiceNoPai = 0;

			for (int i = 0; i < parent.jjtGetNumChildren(); i++) {
				if (this == parent.jjtGetChild(i)) {
					parent.deleteChild(i);
					indiceNoPai = i;
					break;
				}
			}

			for (int i = 0; i < jjtGetNumChildren(); i++) {
				parent.addChild(this.children[i], indiceNoPai + i);
				children[i].jjtSetParent(parent);
				// this.deleteChild(i);
			}
			this.jjtSetParent(null);
			return true;
		} else {
			for (int i = 0; i < jjtGetNumChildren(); i++) {
				Node actualChild = children[i];

				boolean apagou = children[i].deleteUninterestingNodes();
				if (apagou) {

					deleteChild(actualChild);
					i--;
				}
			}
			return false;
		}

	}

	public void dump(String prefix) {
		String printTail = new String("");
		if (symbol != null)
			printTail = new String(" Symbol:" + symbol);
		if (indicesRange != null)
			printTail = new String(printTail + " (" + indicesRange[0] + ":"
					+ indicesRange[1] + ")");

		System.out.println(toString(prefix) + printTail);

		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}

	@Override
	public void setSymbol(String s) {
		symbol = s;

	}

	@Override
	public String getSymbol() {
		return symbol;
	}

	@Override
	public void setSymbolParent(String s) {
		parent.setSymbol(s);

	}

	public String getCodeAux(int raizRangeMinVarsAtribuicao)
			throws SemanticException {
		if (!symbolIsAnOperator()) {
			if (indicesRange == null)
				return new String("new CustomMatrix (" + symbol + ","
						+ raizRangeMinVarsAtribuicao + "))");
			else {
				if (raizRangeMinVarsAtribuicao != (int) Math
						.sqrt(indicesRange[1] + 1 - indicesRange[0]))
					throw new SemanticException(
							"Some variables has different ranges\n");
				return new String("new CustomMatrix (" + symbol + ","
						+ indicesRange[0] + "," + indicesRange[1] + "))");
			}
		} else {

			if (children.length == 2) {

				if (symbol.equals("*") || symbol.equals("/")) {
					return new String(
							"("
									+ children[0]
											.getCodeAux(raizRangeMinVarsAtribuicao)
									+ "."
									+ getCodeOperation(symbol)
									+ "("
									+ children[1]
											.getCodeAux(raizRangeMinVarsAtribuicao)
									+ ")");
				} else {
					return new String(
							""
									+ children[0]
											.getCodeAux(raizRangeMinVarsAtribuicao)
									+ "."
									+ getCodeOperation(symbol)
									+ "("
									+ children[1]
											.getCodeAux(raizRangeMinVarsAtribuicao)
									+ "");
				}
			} else { // tem parenteses

				String resultado = null;
				if (symbol.equals("*") || symbol.equals("/"))
					resultado = new String("(");
				else
					resultado = new String("");

				int indiceFirstChildNotParenteses = getChildXNotParenteses(0);
				int indiceSecondChildNotParenteses = getChildXNotParenteses(1);

				Node firstChildNotParenteses = children[indiceFirstChildNotParenteses];
				Node secondChildNotParenteses = children[indiceSecondChildNotParenteses];

				int numParentesesAbertosAteFirstChildNotParenteses = contaAberturaParentesesAteEncontrarAlgumSimboloDiferente(0);
				int numParentesesFechadosAteNotParentesesFechadosAfterFirstChild = contaFechoParentesesAteEncontrarAberturaParenteses(indiceFirstChildNotParenteses);
				int numParentesesAbertosAntesDeSecondChild = contaAberturaParentesesAteEncontrarAlgumSimboloDiferente(indiceFirstChildNotParenteses+numParentesesFechadosAteNotParentesesFechadosAfterFirstChild+1);
				int numParentesesFechadosDpsDeSecondChild = contaFechoParentesesAteAoFim(indiceSecondChildNotParenteses);

				resultado += stringComNParenteses("(",
						numParentesesAbertosAteFirstChildNotParenteses);
				resultado += firstChildNotParenteses
						.getCodeAux(raizRangeMinVarsAtribuicao);
				resultado += stringComNParenteses(")",
						numParentesesFechadosAteNotParentesesFechadosAfterFirstChild);

				resultado += "." + getCodeOperation(symbol) + "(";
				
				resultado += stringComNParenteses("(",numParentesesAbertosAntesDeSecondChild);
				/*
				if (!lastChildIsVariable()) {// ?!?!? - SE FILHO FOR ESTILO: ( A ) B 
					resultado += stringComNParenteses("(",
							numParentesesAbertosAntesDeSecondChild);
					if (symbol.equals("-")) {
						System.out.println("LAST CHILD IS NOT A VARIABLE! numChild: " + children.length);
					}
				}
				*/
				//else			resultado += stringComNParenteses("(",numParentesesFechadosDpsDeSecondChild	- numParentesesAbertosAntesDeSecondChild);


				resultado += secondChildNotParenteses
						.getCodeAux(raizRangeMinVarsAtribuicao);

				resultado += stringComNParenteses(")",numParentesesFechadosDpsDeSecondChild);
				/*
				if (!lastChildIsVariable()) // ?!?!? - SE FILHO FOR ESTILO: A (
											// B )
					resultado += stringComNParenteses(")",
							numParentesesFechadosDpsDeSecondChild);
				else resultado += stringComNParenteses(")",numParentesesAbertosAteFirstChildNotParenteses - numParentesesFechadosAteNotParentesesFechadosAfterFirstChild);
				*/
				if (symbol.equals("*") || symbol.equals("/"))
					resultado += ")";

				return resultado;
			}
		}
	}

	private int getChildXNotParenteses(int num) {
		int contador = -1;
		for (int i = 0; i < children.length; i++) {
			if (!children[i].getSymbol().equals(")") && !children[i].getSymbol().equals("("))
			{
				contador++;
			}
			if(contador == num)
				return i;
		}
		return 0;
	}

	private int contaAberturaParentesesAteEncontrarAlgumSimboloDiferente(
			int indiceInicio) {
		int contador = 0;
		for (int i = indiceInicio; i < children.length; i++) {
			if (!children[i].getSymbol().equals("("))
				break;
			else
				contador++;
		}
		return contador;
	}

	private String stringComNParenteses(String parenteses,
			int numParentesesAbertosAteFirstChildNotParenteses) {
		String r = new String("");
		
		for (int i = 0; i < numParentesesAbertosAteFirstChildNotParenteses; i++) {
			r += parenteses;
		}
		return r;
	}

	/*
	 * public String getCodeAux(int raizRangeMinVarsAtribuicao) throws
	 * SemanticException {
	 * 
	 * if (symbol.equals("(") || symbol.equals(")")) {
	 * 
	 * return new String(symbol);
	 * 
	 * } else if (!symbolIsAnOperator()) { if (indicesRange == null) return new
	 * String("new CustomMatrix (" + symbol + "," + raizRangeMinVarsAtribuicao +
	 * "))"); else { if (raizRangeMinVarsAtribuicao != (int) Math
	 * .sqrt(indicesRange[1] + 1 - indicesRange[0])) throw new
	 * SemanticException( "Some variables has different ranges\n"); return new
	 * String("(new CustomMatrix (" + symbol + "," + indicesRange[0] + "," +
	 * indicesRange[1] + "))"); } } else {
	 * 
	 * if (children.length == 2) {
	 * 
	 * if (symbol.equals("*") || symbol.equals("/")) { return new String( "(" +
	 * children[0] .getCodeAux(raizRangeMinVarsAtribuicao) + "." +
	 * getCodeOperation(symbol) + "(" + children[1]
	 * .getCodeAux(raizRangeMinVarsAtribuicao) + ")"); } else { return new
	 * String( "" + children[0] .getCodeAux(raizRangeMinVarsAtribuicao) + "." +
	 * getCodeOperation(symbol) + "(" + children[1]
	 * .getCodeAux(raizRangeMinVarsAtribuicao) + ""); } } else { // tem
	 * parenteses if (symbol.equals("*") || symbol.equals("/")) {
	 * 
	 * boolean notParenteses = false; String resultado = new String("(");
	 * 
	 * for (int i = 0; i < children.length; i++) { if ((lastChildIsVariable() &&
	 * !children[i].getSymbol() .equals(")")) || !lastChildIsVariable()) {
	 * resultado += children[i] .getCodeAux(raizRangeMinVarsAtribuicao);
	 * 
	 * String t1 = children[i].getSymbol();
	 * 
	 * if (!t1.equals("(") && notParenteses == false) {
	 * 
	 * if (lastChildIsVariable()) { int nrParenteses = contaFechoParenteses(i);
	 * 
	 * for (int k = 0; k < nrParenteses; k++) resultado += ")"; resultado += "."
	 * + getCodeOperation(symbol) + "(";
	 * 
	 * } else { resultado += "." + getCodeOperation(symbol) + "("; }
	 * 
	 * notParenteses = true; } } }
	 * 
	 * resultado += ")";
	 * 
	 * return resultado;
	 * 
	 * } else { // + ou -
	 * 
	 * boolean notParenteses = false; String resultado = new String("");
	 * 
	 * for (int i = 0; i < children.length; i++) { if ((lastChildIsVariable() &&
	 * !children[i].getSymbol() .equals(")")) || !lastChildIsVariable()) {
	 * resultado += children[i] .getCodeAux(raizRangeMinVarsAtribuicao);
	 * 
	 * String t1 = children[i].getSymbol();
	 * 
	 * if (!t1.equals("(") && notParenteses == false) {
	 * 
	 * if (lastChildIsVariable()) { int nrParenteses = contaFechoParenteses(i);
	 * System.out.println(symbol + " : " + nrParenteses);
	 * 
	 * for (int k = 0; k < nrParenteses; k++) resultado += ")"; resultado += "."
	 * + getCodeOperation(symbol) + "(";
	 * 
	 * } else { resultado += "." + getCodeOperation(symbol) + "("; }
	 * 
	 * notParenteses = true; } } }
	 * 
	 * resultado += "";
	 * 
	 * return resultado;
	 * 
	 * } } } }
	 */
	private boolean lastChildIsVariable() {
		int i;
		for (i = children.length - 1; i > 0; i--)
			if (!children[i].getSymbol().equals(")"))
				break;

		if (contaTodosParentesesFechados() > contaFechoParentesesAteAoFim(i))
			return true;

		return false;
	}

	private int contaTodosParentesesFechados() {
		int resultado = 0;

		for (int i = 0; i < children.length; i++)
			if (children[i].getSymbol().equals(")"))
				resultado++;

		return resultado;
	}

	private int contaFechoParentesesAteAoFim(int min) {
		int resultado = 0;

		for (int i = min; i < children.length; i++) {
			if (children[i].getSymbol().equals(")"))
				resultado++;

		}

		return resultado;
	}

	private int contaFechoParentesesAteEncontrarAberturaParenteses(int min) {
		int resultado = 0;

		for (int i = min; i < children.length; i++) {
			if (children[i].getSymbol().equals(")"))
				resultado++;

			if (children[i].getSymbol().equals("("))
				return resultado;

		}

		return resultado;
	}

	public String getCode() throws SemanticException {
		if (symbol == null) {
			String retorno = new String("");

			for (int i = 0; i < jjtGetNumChildren(); i++) {
				retorno = new String(retorno + children[i].getCode());
			}
			return retorno;
		} else if (isAtribution()) {
			getType();
			int range, raizRange;

			if (indicesRange == null) {
				range = getRange();
				if (range == -1)
					throw new SemanticException("No range was defined");
			} else {
				range = indicesRange[1] + 1 - indicesRange[0];
			}

			raizRange = (int) Math.sqrt(range);
			String retorno;

			if (indicesRange == null) {
				retorno = new String("CustomMatrix.atribui("
						+ children[0].getSymbol() + ",("
						+ children[1].getCodeAux(raizRange) + ".getArrayCopy"
						+ tipoRetorno(children[0]) + "(), " + range + ");\n");

			} else {
				retorno = new String("CustomMatrix.atribui("
						+ children[0].getSymbol() + ",("
						+ children[1].getCodeAux(raizRange) + ".getArrayCopy"
						+ tipoRetorno(children[0]) + "(), " + indicesRange[0]
						+ "," + indicesRange[1] + ");\n");
			}

			return retorno;

		} else
			return null;
	}

	/*
	 * //ONLY CALLED IN START PRODUCTION WHEN SYMBOL == NULL public void
	 * throwExceptionIfNoRangeWasDefined() throws SemanticException { for (int i
	 * = 0; i < jjtGetNumChildren(); i++) { if (children[i].getRangeMin() == -1)
	 * throw new SemanticException("No range was defined in" + (i+1) +
	 * "ยบ Atribution (=)"); } }
	 */

	private String tipoRetorno(Node node) {
		return VariableStore.getType(node.getSymbol());
	}

	// NOT CALLED WHEN SYMBOL == NULL
	public String getType() {
		if (jjtGetNumChildren() == 0) {
			return VariableStore.getType(symbol);

		} else {
			String type = null;

			for (int i = 0; i < jjtGetNumChildren(); i++) {
				String typeChild = children[i].getType();

				if (type != null && typeChild != null
						&& !type.equals(typeChild)) {
					// Geracao de Warning
					Warning.push("Variables with different types");
				}

				if (type == null && typeChild != null)
					type = typeChild;
			}

			return type;
		}
	}

	// NOT CALLED WHEN SYMBOL == NULL
	public int getRange() throws SemanticException {
		if (jjtGetNumChildren() == 0) {
			if (indicesRange != null)
				return (indicesRange[1] + 1 - indicesRange[0]);
			else
				return VariableStore.getRange(symbol);

		} else {
			int range = -1;

			for (int i = 0; i < jjtGetNumChildren(); i++) {
				int rangeChild = children[i].getRange();

				if (range != -1 && rangeChild != -1 && range != rangeChild)
					throw new SemanticException(
							"Different range in operating variables");

				if (range == -1 && rangeChild != -1)
					range = rangeChild;
			}

			return range;
		}
	}

	private boolean isAtribution() {
		return (symbol.equals("="));
	}

	private String getCodeOperation(String op) {
		switch (op) {
		case "*":
			return "times";
		case "/":
			return "divide";
		case "+":
			return "plus";
		case "-":
			return "minus";
		default:
			return null;

		}
	}

	private boolean symbolIsAnOperator() {
		return (getCodeOperation(symbol) != null);
	}

	@Override
	public boolean deleteFactorAfterTerm() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void addChild(Node node, int i) {
		Node[] nos = new Node[children.length];
		System.arraycopy(children, 0, nos, 0, children.length);

		children = new Node[children.length + 1];

		for (int k = 0; k < children.length; k++) {
			if (k < i)
				children[k] = nos[k];
			else if (k == i) {
				children[i] = node;
			} else if (k > i) {
				children[k] = nos[k - 1];
			}
		}
	}

}

/*
 * JavaCC - OriginalChecksum=6de11f5939191cba166b5dd216acf9a6 (do not edit this
 * line)
 */
